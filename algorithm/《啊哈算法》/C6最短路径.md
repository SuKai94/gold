第6章 最短路径
===

### 第1节 只有五行的算法 Floyd-Warshall

使用二维数组存储图

先假设只允许经过1号顶点，求任意两点之间的最短路径只需判断e[i][1]+e[1][j]是否小于e[i][j]；接下来，只允许经过1和2顶点的情况下，任意两点之间的最短路径：只需在刚刚只经过1号顶点的结果下，再判断经过2号的情况，即判断e[i][2]+e[2][j]是否比e[i][j]小

核心代码五行

```c
for(k=1; k<=n ;k++)
{
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
            if(e[i][j] > e[i][k]+e[k][j])  e[i][j]=e[i][k]+e[k][j];    
    }
}
```

时间复杂度O(N三方)

此算法无法解决“负权回路”，因为“负权回路”无最短路径

### 第2节 Dijkstra算法 通过边松弛

也是采用二位数组e存储顶点之间边关系，另外一维数组dis存储1号顶点到其余各顶点的初始路程

基本思想：每次找到离源点s最近的一个顶点，然后以该顶点u为中心，考察所有u为起点的边，对每一条边进行松弛，如果存在一条u到v的边，使得dis[u]+e[u][v]比dis[v]小，就采用新值代替，直至所有顶点都遍历完毕

时间复杂度O(N平方)

---

使用邻接表存储图，使用数组实现邻接表

用u,v,w记录每条边的信息，u[i],v[i]和w[i]表示第i条边是从第u[i]顶点到v[i]定点 的，权值为w[i]

first数组，next数组.....

无法解决负权边的图

### 第3节 Bellman-Ford 解决负权边

核心算法

```c
for(k=1; k<=n-1; k++)
{
    for(i=1; i<=m; i++)
    {
        if(dis[v[i]] > dis[u[i]]+w[i])
            dis[v[i]] = dis[u[i]]+w[i];    
    }
}
```

对所有条件已知的边进行松弛操作，总共进行n-1轮，为什么是n-1?

第一轮对所有边进行松弛，得到是只能经过一条边，到达其余各顶点的最短路径；第二轮得到最多经过两条边的最短路径，所以：

答案是，最多进行n-1轮，因为一个包含n个顶点的图中，任意两点之间的最短路径最多包含n-1边

### 第4节 Bellman-Ford的队列优化

实际情况中，BF算法经常在未到达n-1轮前，就计算出了最短路径，n-1是最大值，这就启发我们每次仅对最短路径估计值发生变化了的顶点的所有出边执行松弛操作

初始时，将源点加入队列，每次从队首取出一个顶点，并对与其相邻的所有顶点组成的出边进行松弛操作，若松弛成功，且这个相邻的顶点不在队列中，就将它加入到队列。当前顶点处理完毕，立即出队，并对下一个新队首进行同样操作，直至队列为空

### 第5节 最短路径算法对比分析

见书上表格
