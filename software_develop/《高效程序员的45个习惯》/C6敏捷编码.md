第6章 敏捷编码
===

新项目在刚开始着手开发时，代码容易理解和上手，然而开发人员在完成任务时，可能会难以抵挡诱惑为节省时间而走“捷径”，从而难以控制

所以，我们要细心“照看”代码

### 25.代码要清晰地表达意图

开发代码，应该注重可读性，而不只图自己方便。从衡量标准看，代码清晰程度的优先级应排在执行效率之前

应该让团队或者自己，可以读懂自己一年前写的代码

### 26.用代码沟通

建立代码文档无外乎两种方式：利用代码本身；利用注释沟通代码之外问题

但不要用注释包裹你的代码；因此，程序的变量命名很重要，程序元素的命名是代码读者必读的部分，使用细心挑选的名称和清晰的执行路径，代码几乎不要注释

注释可以用来为读者指定一条正确的代码访问路线图 。为代码中每个类或模块添加一个短小的描述，说明其目的以及是否有任何需求，对于类中的每个方法，可能说明下列信息：

- 目的：为什么需要这个方法
- 需求（前置条件）：方法需要什么样的输入，对象必须处于何种状态，才能让这个方法工作
- 承诺（后置条件）：方法成功执行后，对象处于何种状态，有哪些返回值
- 异常：可能发生什么样的问题？会抛出什么样的异常

但注释不能替代优秀的代码，在代码可以传递意图的地方不要注释

### 27.动态评估取舍

动态评估权衡。考虑性能，便利性，生产力，成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上，不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化，因为，永远没有最佳的解决方案

即使不能面面俱到，你也应该觉得得到了客户最重要的东西---客户认为有价值的特性

### 28.增量式编程

在很短的编辑/构建/测试循环中编写代码。这比长时间仅仅做编码工作好得多，可以创建更加清晰，简单，易于维护的代码

在写了几行代码后，你会迫切地希望进行一次构建/测试循环，在没有得到反馈之前，你不想走太远

### 29.保持简单

简单不是简陋，优雅的代码一看上去，就知道它的用处，而且很简洁。而不是编写历史上最复杂的程序

当你觉得代码中没有一行是多余的，而且能交付全部功能时，这种感觉就对了

### 30.编写内聚的代码

内聚性用来评估一个组件（包，模块或配件）中成员功能相关性。内聚程度高，表明各个成员共同完成一个功能特性或一组功能特性。内聚程度地的话，表明各个成员提供的功能互不相干

如何组织一个组件中代码，会对开发人员生产力和代码维护性产生重要影响。在决定创建一个类时，问问自己，这个类功能是不是与组件中某个类功能类似，而且功能紧密相关，这就是组件级的内聚性

类也遵循内聚性，如果一个类的方法和属性共同完成一个功能，这个类就是内聚的

让类的功能尽量集中，组件尽量小。每个类或组件只做一件事

### 31.告知，不要询问

将命令与查询分离开来

作为某段代码的调用者，开发人员绝对不能基于被调用对象的状态来做出任何决定，更不能去改变对象的状态，这样的逻辑应该是被调用对象的责任，而不是你的

与告知，不要询问相关的一个技术是：命令与查询相分离模式。把所有“命令”代码放在一起，所有“查询”代码放在一起

一些常规命令可能会改变对象状态，而且有可能返回一些有用的值，以方便调用。一个查询仅仅提供给开发人员对象的状态，并不会对其外部的可见状态进行修改

不要抢别的对象或组件的工作，告诉它做什么，然后专注自己的职责就行

### 32.根据契约进行替换

针对is-a关系使用继承；针对has-a或uses-a关系使用委托

当使用继承时，要想想派生类是否可以替换基类。如果不能，就要问问自己为什么使用继承。如果答案是希望在编写新类时，重用基类代码，或者聚合更合适。聚合就是在类中包含一个对象，该对象是其他类的实例，开发人员将责任委托给对象完成（也叫委托技术）
